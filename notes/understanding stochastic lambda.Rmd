---
title: "Why is Stochastic Lambda > Deterministic?"
author: "Eric R. Scott"
date: "2022-04-21"
output: 
  html_document: 
    toc: yes
    toc_float: yes
    number_sections: yes
    highlight: kate
    code_folding: show
    theme:
      version: 4
      bootswatch: flatly
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
library(conflicted)

conflict_prefer("lag", "dplyr")
conflict_prefer("filter", "dplyr")
set.seed(123)
```

*Last compiled: `r Sys.Date()`*

# Purpose

Figure out what the heck is going on.

# Load Data

```{r include=FALSE}
## Load your packages, e.g. library(targets).
source(here("packages.R"))

## Load your R files
lapply(list.files(here("R"), full.names = TRUE), source)

withr::with_dir(here(),{
  tar_load(data_full)
  tar_load(vit_other_ff)
})
```

# Pick two years, worst and best

Fit determinsitic IPMs to all years separately to identify a bad year and a good year.
Then subset data to only contain those years

```{r warning=FALSE, class.source = 'fold-hide'}
single_years <-   
  data_full %>%
  filter(year>1999) %>% 
  select(-L, -spei_history) %>% 
  group_by(year_fct) %>% 
  group_split()

  
vit_list_yr <- 
  single_years %>% 
  filter(habitat == "1-ha") %>% 
  map(~{
    vit_list_det_ff = c(
      list(
        vit_surv = surv_det(.x),
        vit_size = size_det(.x),
        vit_flwr = flwr_det(.x),
        vit_size_sdlg = size_sdlg_det(.x),
        vit_surv_sdlg = surv_sdlg_det(.x)
      ),
      vit_other_ff)
    })
    
ipms_single_yr <-
  map(vit_list_yr, ~{
    make_proto_ipm_det(.x) %>% 
      make_ipm(iterations = 1000,  #only needs 100 to converge
               normalize_pop_size = FALSE, # to run as PVA
               usr_funs = list(get_scat_params = get_scat_params))
  })

lambdas <- ipms_single_yr %>% map_dbl(lambda)
```

```{r warning=FALSE}
#worst year
(worst_year <- c(2000:max(data_full$year))[which.min(lambdas)]); min(lambdas)

#best year
(best_year <- c(2000:max(data_full$year))[which.max(lambdas)]); max(lambdas)

two_yrs <- data_full %>% filter(year %in% c(best_year, worst_year))
```

# Fit IPMs

## Deterministic

Fit a deterministic IPM with just those two years of data

```{r warning=FALSE, class.source = 'fold-hide'}
vit_list_det_ff = c(
  list(
    vit_surv = surv_det(two_yrs),
    vit_size = size_det(two_yrs),
    vit_flwr = flwr_det(two_yrs),
    vit_size_sdlg = size_sdlg_det(two_yrs),
    vit_surv_sdlg = surv_sdlg_det(two_yrs)
  ),
  vit_other_ff)

ipm_det_ff = make_proto_ipm_det(vit_list_det_ff) %>% 
  make_ipm(iterations = 1000,  #only needs 100 to converge
           normalize_pop_size = FALSE, # to run as PVA
           usr_funs = list(get_scat_params = get_scat_params))
lambda(ipm_det_ff)
```

## Stochastic

The stochastic IPM requires re-writing the `proto_ipm` because it's now using different parameter sets for year.
This now uses vital rates models where there is a random effect of year fit such that each year can have a different shape smoother (but not different wiggliness).

```{r warning=FALSE, class.source = 'fold-hide'}
## forets fragments
vit_list_stoch_ff = c(
  list(
    vit_surv = surv_raneff(two_yrs),
    vit_size = size_raneff(two_yrs),
    vit_flwr = flwr_raneff(two_yrs),
    vit_size_sdlg = size_sdlg_raneff(two_yrs),
    vit_surv_sdlg = surv_sdlg_raneff(two_yrs)
  ), 
  vit_other_ff)

proto_ipm_stoch_ff <- 
  init_ipm(
    sim_gen = "general",
    di_dd = "di",
    det_stoch = "stoch",
    kern_param = "kern"
  ) %>% 
  
  # Define growth and survival kernel
  define_kernel(
    "P_yr", #_yr makes a different P kernel for each value of `yr` from par_set_indices
    formula = s_z * G_z1z * d_log_size,
    family  = "CC",
    # Probability of survival
    s_z = predict(vit_surv,
                  newdata = tibble(log_size_prev = log_size_1, year_fct = yr),
                  type = 'response'),
    # Growth
    G_z1z = dt.scaled(
      log_size_2,
      df   = size_nu,
      mean = size_mu,
      sd   = size_sd
    ),
    size_mu = predict(vit_size,
                      newdata = tibble(log_size_prev = log_size_1, year_fct = yr),
                      type = 'response'),
    size_nu = get_scat_params(vit_size)["nu"],
    size_sd = get_scat_params(vit_size)["sd"],
    
    data_list = vit_list_stoch_ff,
    states          = list(c('log_size')),
    uses_par_sets   = TRUE,
    par_set_indices = list(yr = c(2001, 2003)),
    evict_cor       = TRUE,
    evict_fun       = truncated_distributions("t.scaled", "G_z1z")
  ) %>% 
  
  # Define fecundity and recruitment kernel
  define_kernel(
    "go_sdlg_yr",
    formula = p_f * fruits * seeds * g_e * d_log_size,
    family  = "CD",
    # probability of flowering
    p_f = predict(vit_flwr,
                  newdata = tibble(log_size_prev = log_size_1, year_fct = yr),
                  type = 'response'),
    fruits = predict(vit_fruits,
                     newdata = tibble(log_size_prev = log_size_1),
                     type = 'response'), 
    seeds = exp(coef(vit_seeds)[1]), #mean seeds per fruit
    g_e = vit_germ_est,
    
    data_list     = vit_list_stoch_ff,
    states        = list(c('log_size', 'sdlg')),
    uses_par_sets = TRUE,
    par_set_indices = list(yr = c(2001, 2003))
  ) %>% 
  
  define_kernel(
    name = "stay_sdlg",
    formula = 0,
    family = "DD",
    states = list(c("sdlg")),
    evict_cor = FALSE
  ) %>% 
  
  # Enter into post-seedling
  define_kernel(
    name = "leave_sdlg_yr",
    formula = s_sdlg * G_z2_sdlg,
    family = "DC",
    s_sdlg = predict(vit_surv_sdlg,
                     newdata = tibble(year_fct = yr),
                     type = 'response'), #intercept from intercept-only glm
    G_z2_sdlg = dt.scaled(
      x    = log_size_2,
      df   = size_sdlg_nu,
      mean = size_sdlg_mu,
      sd   = size_sdlg_sd
    ),
    size_sdlg_mu = coef(vit_size_sdlg)[1], #intercept from intercept-only glm
    size_sdlg_nu = get_scat_params(vit_size_sdlg)["nu"],
    size_sdlg_sd = get_scat_params(vit_size_sdlg)["sd"],
    
    data_list = vit_list_stoch_ff,
    states = list(c("sdlg", "log_size")),
    uses_par_sets = TRUE,
    par_set_indices = list(yr = c(2001, 2003)),
    evict_cor = TRUE,
    evict_fun = truncated_distributions("t.scaled", "G_z2_sdlg")
  ) %>% 
  
  # define implementation with midpoint rule
  define_impl(make_impl_args_list(
    kernel_names = c("P_yr",        "go_sdlg_yr", "stay_sdlg", "leave_sdlg_yr"),
    int_rule = "midpoint",
    state_start  = c("log_size", "log_size", "sdlg",     "sdlg"),
    state_end    = c("log_size", "sdlg",     "sdlg",     "log_size")
  )) %>% 
  #define lower bound, upper bound, and number of meshpoints for log_size
  define_domains(log_size = c(0, 8.018296, 100)) %>%  
  #arbitrary starting population state
  define_pop_state(n_log_size = runif(100), n_sdlg = .1)
```

Iterate IPM with 1000 iterations

```{r warning=FALSE}
ipm_stoch_ff <- 
  proto_ipm_stoch_ff %>%
  make_ipm(iterations = 1000,
           normalize_pop_size = FALSE, # to run as PVA
           usr_funs = list(get_scat_params = get_scat_params))
```

# Investigation

First, with just the worst and best years, is the stochastic lambda still higher than the deterministic?

```{r}
lambda(ipm_det_ff) 
lambda(ipm_stoch_ff, log = FALSE, burn_in = 0.2)
```

Yes, stochastic lambda is still a bit higher!

What about the averages for each year?
Are they consistent with a bad and good year?

```{r}
all_lams <- 
  tibble(year = ipm_stoch_ff$env_seq,
         lambda = lambda(ipm_stoch_ff, type_lambda = "all")[,1])
all_lams %>%
  group_by(year) %>%
  summarize(mean(lambda))
```

Yes, but both the good and bad years mean lambdas are *greater* than the deterministic lambda.

How do the mean lambdas from the good and bad year compare to the deterministic lambdas from individual years?

```{r}
max(lambdas)
min(lambdas)
```

The deterministic lambda for 2001 is a lot higher than the mean of the 2001 lambdas from the stochastic simulation and the deterministic lambda for 2003 is a lot lower than the mean of the 2003 lambdas from the stochastic simulation.
This makes sense to me, as fitting year as a random effect rather than a fixed effect will shrink estimates toward a global mean.

How do they compare at the level of vital rates?

```{r class.source = 'fold-hide'}
newdata <- expand.grid(
  log_size_prev = seq(min(two_yrs$log_size_prev, na.rm = TRUE), max(two_yrs$log_size_prev, na.rm = TRUE), length.out = 50),
  year_fct = as.character(c(2001, 2003))
)

safe_predict <- possibly(predict, NA)

#deterministic, just 2001
det_fitted_2001 <- 
  vit_list_yr[[which.max(lambdas)]] %>% 
  map_df(~safe_predict(.x, newdata = newdata, type = "response")) %>% 
  bind_cols(newdata) %>% 
  select(-vit_fruits, -vit_seeds, -vit_germ_est) %>% 
  pivot_longer(starts_with("vit_"), names_to = "vital_rate", values_to = ".fitted", names_prefix = "vit_") %>% 
  mutate(year_fct = "det. 2001")

#deterministic, just 2003
det_fitted_2003 <- 
  vit_list_yr[[which.min(lambdas)]] %>% 
  map_df(~safe_predict(.x, newdata = newdata, type = "response")) %>% 
  bind_cols(newdata) %>% 
  select(-vit_fruits, -vit_seeds, -vit_germ_est) %>% 
  pivot_longer(starts_with("vit_"), names_to = "vital_rate", values_to = ".fitted", names_prefix = "vit_") %>% 
  mutate(year_fct = "det. 2003")

#deterministic with both years combined
det_fitted <- 
  vit_list_det_ff %>% 
  map_df(~safe_predict(.x, newdata = newdata, type = "response")) %>% 
  bind_cols(newdata) %>%
  select(-vit_fruits, -vit_seeds, -vit_germ_est) %>% 
  pivot_longer(starts_with("vit_"), names_to = "vital_rate", values_to = ".fitted", names_prefix = "vit_") %>% 
  mutate(year_fct = "det. both years")

#stochastic
stoch_fitted <- 
  vit_list_stoch_ff %>%
  map_df(~safe_predict(.x, newdata= newdata, type = "response")) %>%
  bind_cols(newdata) %>%
  select(-vit_fruits, -vit_seeds, -vit_germ_est) %>% 
  pivot_longer(starts_with("vit_"), names_to = "vital_rate", values_to = ".fitted", names_prefix = "vit_") %>% 
  mutate(year_fct = paste("stoch.", year_fct))

bind_rows(stoch_fitted, det_fitted, det_fitted_2001, det_fitted_2003) %>% 
  ggplot(aes(x = log_size_prev, y = .fitted, color = year_fct, linetype = year_fct)) +
  geom_line(alpha = 0.9) +
  facet_wrap(~vital_rate, scales = "free")

```

For the stochastic models, the two years are nearly indistinguishable for seedlings.
I believe this is because of shrinkage---there is little information for either year so means are shrunk toward global average.
You can see this more clearly for flowering probability where the order of lines at the larger end is 2001 deterministic (essentially a fixed effect), 2001 stochastic (random effect), both years combined, 2003 stochastic (random effect), and 2003 deterministic (fixed effect).
